---
title: Annotating Neutrophil eQTL with Blueprint Data
author: Peter Humburg
date: `r format(Sys.time(), "%a %d %b %Y")`
---

```{r setup, include=FALSE}
library(GenomicRanges)
library(ggplot2)
library(scales)
library(pander)

opts_knit$set(root.dir = "/well/hill/Vivek/eQTL")
opts_chunk$set(autodep=TRUE)
opts_chunk$set(tidy=TRUE)
opts_chunk$set(echo=FALSE)
opts_chunk$set(autodep=TRUE)
options(figcap.prefix = "Figure", figcap.sep = ":", figcap.prefix.highlight = "**")
options(tabcap.prefix = "Table", tabcap.sep = ":", tabcap.prefix.highlight = "**")
```

```{r functions, include=FALSE}
loadBlueprint <- function(files){
	splitNames <- strsplit(basename(files), ".", fixed=TRUE)
	sample <- sapply(splitNames, "[[", 1)
	type <- sapply(splitNames, "[[", 2)
	df <- data.frame(file=files, sample=sample, type=type)
	gr <-lapply(files, rtracklayer::import.bed, genome="hg19", asRangedData=FALSE)
	list(meta=df, ranges=gr)
}

annotateSNPs <- function(snps, regions, outNames){
	meta <- mcols(snps)
	if(missing(outNames)){
		outNames <- names(regions)
	}
	for(i in 1:lengthh(regions)){
		meta[[outNames[i]]] <- mcols(distanceToNearest(snps, regions))$distance
	}
	mcols(snps) <- meta
	snps
}

figRef <- local({
    tag <- numeric()
    created <- logical()
    used <- logical()
    function(label, caption, prefix = options("figcap.prefix"), 
        sep = options("figcap.sep"), prefix.highlight = options("figcap.prefix.highlight")) {
        i <- which(names(tag) == label)
        if (length(i) == 0) {
            i <- length(tag) + 1
            tag <<- c(tag, i)
            names(tag)[length(tag)] <<- label
            used <<- c(used, FALSE)
            names(used)[length(used)] <<- label
            created <<- c(created, FALSE)
            names(created)[length(created)] <<- label
        }
        if (!missing(caption)) {
            created[label] <<- TRUE
            paste0(prefix.highlight, prefix, " ", i, sep, prefix.highlight, 
                " ", caption)
        } else {
            used[label] <<- TRUE
            paste(prefix, tag[label])
        }
    }
})

tabRef <- local({
    tag <- numeric()
    created <- logical()
    used <- logical()
    function(label, caption, prefix = options("tabcap.prefix"), 
        sep = options("tabcap.sep"), prefix.highlight = options("tabcap.prefix.highlight")) {
        i <- which(names(tag) == label)
        if (length(i) == 0) {
            i <- length(tag) + 1
            tag <<- c(tag, i)
            names(tag)[length(tag)] <<- label
            used <<- c(used, FALSE)
            names(used)[length(used)] <<- label
            created <<- c(created, FALSE)
            names(created)[length(created)] <<- label
        }
        if (!missing(caption)) {
            created[label] <<- TRUE
            paste0(prefix.highlight, prefix, " ", i, sep, prefix.highlight, 
                " ", caption)
        } else {
            used[label] <<- TRUE
            paste(prefix, tag[label])
        }
    }
})
```

# Introduction
The aim of this analysis is to annotate eQTL obtained from the analysis
of neutrophils with the results of bisulfite sequencing and ChIP-seq
for several histone modifications generated by the Blueprint consortium.
BED files with ChIP-seq peaks and hyper- and hypo-methylated regions
all neutrophil samples were obtained form the Blueprint ftp server.

All eQTL significant at an FDR threshold of 0.05 will be annotated with
the distance to the closest hyper/hypo methylated site as well as the distance
to the available histone marks. The subsequent analysis of these distances
focuses on eQTL of particular interest, e.g. the lead SNP for each gene or
all peak eQTL.

```{r loadEQTL, echo=FALSE, cache=TRUE}
load("blueprint/Neut_results/Neut_neutonly_140221_imputed.rdata")
snppos <- read.table("Neut/Matrix_eQTL_SNP_loc_hg19_090912.txt", header=TRUE,
		stringsAsFactors=FALSE)
cis <- merge(snppos, subset(me$cis$eqtls, FDR < 0.05), by.x="snp", by.y="snps")
cis <- with(cis, GRanges(seqnames=Rle(paste0("chr", chrm_snp)), 
		ranges=IRanges(start=pos, width=1),
		snp=snp, gene=gene, statistic=statistic, pvalue=pvalue,
		FDR=FDR, beta=beta))
trans <- merge(snppos, subset(me$trans$eqtls, FDR < 0.05), by.x="snp", by.y="snps")
trans <- with(trans, GRanges(seqnames=Rle(paste0("chr", chrm_snp)), 
		ranges=IRanges(start=pos, width=1),
		snp=snp, gene=gene, statistic=statistic, pvalue=pvalue,
		FDR=FDR, beta=beta))

rm(me)
```

To be able to assess the significance of the proximity between eSNPs and
features of interest we also generate the corresponding background distributions
by considering the distance between the features and all tested SNPs.

```{r loadSNPs, echo=FALSE, cache=TRUE}
allSNPs <- read.table("Neut/ImputedGeno4QTL_140130.txt", header=FALSE, skip=1, sep="\t", nrows=2L)
colCount <- ncol(allSNPs)
allSNPs <- read.table("Neut/ImputedGeno4QTL_140130.txt", header=FALSE, skip=1, sep="\t",
		colClasses=c("character", rep("NULL", colCount-1)))
names(allSNPs) <- "snp"
allSNPs <- merge(snppos, allSNPs)
allSNPs <- with(allSNPs, GRanges(seqnames=Rle(paste0("chr", chrm_snp)), 
		ranges=IRanges(start=pos, width=1), snp=snp))
```

# Methylation data
## Data processing
The BED files provided by Blueprint do not conform to the BED specification.
This causes difficulties when trying to process them with BED file parsers.
To remedy this the first five columns of each file are extracted prior
to further analysis.

```{r reformatBED, engine="bash", echo=FALSE, cache=TRUE}
for file in $(ls blueprint/WGBS_Neut/*.bed)
do
	cut -f1-5 $file > ${file}5
done	
```
The re-formatted BED files are imported into R for further processing with 
Bioconductor. 

```{r loadWGBS, echo=FALSE, cache=TRUE}
meth <- loadBlueprint(dir("blueprint/WGBS_Neut", ".bed5", full.names=TRUE))
```

## Defining regions of hyper- and hypo-methylation
Regions considered to be either hyper- or hypo-methylated are defined as follows.
A genomic region is considered to be hyper-methylated in neutrophils if it
meets the criteria for hyper-methylation used in the analysis of the Blueprint consortium
(average methylation of >0.75 and all CpGs in the regions have methylation >0.5)
in at least two neutrophil samplesand the region isn't hypo-methylated in any of 
the neutrophil samples. Hypo-methylated regions are defined accordingly.

```{r defineRegions, echo=FALSE, cache=TRUE}
allHypo <- do.call(union, c(meth$ranges[meth$meta$type == "hypo_meth"], ignore.strand=TRUE))
allHyper <- do.call(union, c(meth$ranges[meth$meta$type == "hyper_meth"], ignore.strand=TRUE))
hypo <- lapply(meth$ranges[meth$meta$type == "hypo_meth"], setdiff, allHyper)
hyper <- lapply(meth$ranges[meth$meta$type == "hyper_meth"], setdiff, allHypo)
```

```{r regionLength, echo=FALSE, fig.cap="Length distribution of hyper- and hypo-methylated regions"}
regLen <- list()
regLen$hypo <- data.frame(length=unlist(lapply(hypo, width)), type="hypo methylated")
regLen$hyper <- data.frame(length=unlist(lapply(hyper, width)), type="hyper methylated")
regLen <- rbind(regLen$hypo, regLen$hyper)
ggplot(regLen, aes(x=length, y=..density..)) + geom_histogram(binwidth=100) + facet_grid( ~ type) + 
		theme_bw() + xlim(0,7e4) + ylim(0,0.00075)
```

Considering the length distribution of hyper- and hypo-methylated regions it is apparent
that a lot of regions are quite short while some, especially for hyper-methylation,
are quite large. This is further emphasised by the following summary table.

```{r lengthSummary, echo=FALSE, results="asis"}
lengthSum <- tapply(regLen$length, regLen$type, summary)
set.caption("Summary of length distribution for hypo- and hyper-methylated regions.")
pander(do.call(cbind, lengthSum), style="rmarkdown")
```

Based on this we set the minimum overlap between regions from different individuals
to 50bp. 
```{r overlapRegions, echo=FALSE, cache=TRUE, fig.caption="Length distribution of consensus regions."}
hypo <- Reduce(function(x,y) subsetByOverlaps(x,y, minoverlap=50L), hypo)
hyper <- Reduce(function(x,y) subsetByOverlaps(x,y, minoverlap=50L), hyper)
regLen.comb <- data.frame(length=c(width(hypo), width(hyper)), 
		type=c(rep("hypo methylated", length(hypo)), rep("hyper methylated", length(hyper))),
		consensus=TRUE)
regLen$consensus <- FALSE
regLen.comb <- rbind(regLen.comb, regLen)
regLen.comb$type <- factor(as.character(regLen.comb$type), 
		levels=c("hypo methylated", "hyper methylated"))
ggplot(regLen.comb, aes(x=length, colour=consensus)) + 
		geom_density() + facet_grid( ~ type) + 
		theme_bw() + xlim(0,7e4) + ylim(0,0.00075)
```

While this excludes small regions the effect on the length of the remaining regions is limited,
consistent with substantial overlaps between samples. A total of 
`r nrow(subset(regLen.comb, consensus & type == "hypo methylated"))` hypo- and
`r nrow(subset(regLen.comb, consensus & type == "hyper methylated"))` hyper-methylated
regions remain after filtering. 

```{r lengthSummaryConsensus, echo=FALSE, results="asis"}
lengthSum.comb <- with(subset(regLen.comb, consensus), tapply(length, type, summary))
set.caption("Summary of length distribution for hypo- and hyper-methylated consensus regions.")
pander(do.call(cbind, lengthSum.comb), style="rmarkdown")
```

## Annotating eQTL
All significant eQTL are annotated with their distance to the closest hyper- and 
hypo-methylated regions.

```{r methDist, echo=FALSE, cache=TRUE, dependson=c("loadSNPs", "overlapRegions", "loadEQTL")}
allSNPs <- annotateSNPs(allSNPs, list(hypo_meth=hypo, hyper_meth=hyper))
cis <- annotateSNPs(cis, list(hypo_meth=hypo, hyper_meth=hyper))
trans <- annotateSNPs(trans, list(hypo_meth=hypo, hyper_meth=hyper))
```

Considering the most significant SNP for each gene, in addition to the
overal distribution of distances to the closest methylation island the
number of SNPs within islands, i.e. those with distance 0, are of
particular interest.

```{r methDistZero, echo=FALSE, fig.cap="Proportion of eSNPs contained within methylation islands"} 
cisLeads <- by(mcols(cis), mcols(cis)$gene, function(x) x$snp[which.min(x$pvalue)])
transLeads <- by(mcols(trans), mcols(trans)$gene, function(x) x$snp[which.min(x$pvalue)])
cisDF <- mcols(subset(cis, snp %in% cisLeads))
cisDF <- data.frame(eQTL="cis", feature=c(rep("hypo methylation", nrow(cisDF)),
			rep("hyper methylation", nrow(cisDF))), 
		distance=c(cisDF$hypo_meth, cisDF$hyper_meth), stringsAsFactors=FALSE)
transDF <- mcols(subset(trans, snp %in% transLeads))
transDF <- data.frame(eQTL="trans", feature=c(rep("hypo methylation", nrow(transDF)),
			rep("hyper methylation", nrow(transDF))), 
		distance=c(transDF$hypo_meth, transDF$hyper_meth), stringsAsFactors=FALSE)
allDF <- data.frame(eQTL="background", feature=c(rep("hypo methylation", nrow(metaAll)),
			rep("hyper methylation", nrow(metaAll))), 
		distance=c(metaAll$hypo_meth, metaAll$hyper_meth), stringsAsFactors=FALSE)

methDistDF <- rbind(cisDF, allDF)
methDistDF$contained <- methDistDF$distance == 0
ggplot(methDistDF, aes(x=eQTL, fill=contained)) + geom_bar(position="fill") + 
		facet_grid(~ feature) + scale_y_continuous(labels=percent_format()) +
		theme_bw()
```

```{r methDistZeroTest, echo=FALSE, cache=TRUE}
containedCount <- list()
containedCount$hypo <- c(background=sum(subset(allDF, 
				feature == "hypo methylation")$distance == 0),
			cis=sum(subset(cisDF, feature == "hypo methylation")$distance == 0),
			trans=sum(subset(transDF, feature == "hypo methylation")$distance == 0))
containedCount$hyper <- c(background=sum(subset(allDF, 
				feature == "hyper methylation")$distance == 0),
			cis=sum(subset(cisDF, feature == "hyper methylation")$distance == 0),
			trans=sum(subset(transDF, feature == "hyper methylation")$distance == 0))
totalCount <- c(background=nrow(allDF), cis=nrow(cisDF), trans=nrow(transDF))
contingencyTable <- list()
contingencyTable$hypo <- list()
contingencyTable$hypo$cis <- matrix(c(containedCount$hypo["cis"], 
			totalCount["cis"] - containedCount$hypo["cis"], 
			containedCount$hypo["background"], 
			totalCount["background"] - containedCount$hypo["background"]), ncol=2)
contingencyTable$hypo$trans <- matrix(c(containedCount$hypo["trans"], 
			totalCount["trans"] - containedCount$hypo["trans"], 
			containedCount$hypo["background"], 
			totalCount["background"] - containedCount$hypo["background"]), ncol=2)
contingencyTable$hyper <- list()
contingencyTable$hyper$cis <- matrix(c(containedCount$hyper["cis"], 
			totalCount["cis"] - containedCount$hyper["cis"], 
			containedCount$hyper["background"], 
			totalCount["background"] - containedCount$hyper["background"]), ncol=2)
contingencyTable$hyper$trans <- matrix(c(containedCount$hyper["trans"], 
			totalCount["trans"] - containedCount$hyper["trans"], 
			containedCount$hyper["background"], 
			totalCount["background"] - containedCount$hyper["background"]), ncol=2)
fisherTest <- lapply(contingencyTable, lapply, fisher.test)
```
The proportion of cis eSNPs located in hypo-methylated regions
(`r containedCount$hypo["cis"]/totalCount["cis"]*100`%) is substantially
higher than would be expected by chance 
(only `r containedCount$hypo["background"]/totalCount["background"]*100`% 
of imputed SNPs are located in hypo-methylated regions). This corresponds
to an odd's ratio of `r format(fisherTest$hypo$cis$estimate, digits=2,nsmall=1)`. 
The significance of this difference is confirmed via Fisher's exact test.

```{r echo=FALSE, results="asis"}
set.caption(paste0("Fisher's Exact Test for Count Data: ",
			paste(containedCount$hypo[c("background", "cis")], collapse=" and "), " out of ", 
			paste(totalCount[c("background", "cis")], collapse=" and "), " respectively."))
pander(fisherTest$hypo$cis, style="rmarkdown")
```
  
For the much more common hyper-methylated sites the difference between eSNPs and
background is less pronounced. Overall 
`r containedCount$hyper["background"]/totalCount["background"]*100`% of imputed SNPs
fall within a hyper-methylated region while only 
`r containedCount$hyper["cis"]/totalCount["cis"]*100`% are located within one.
This corresponds to an odd's ratio of 
`r format(fisherTest$hyper$cis$estimate, digits=2,nsmall=1)`. 
The significance of this difference is confirmed via Fisher's exact test.

```{r echo=FALSE, results="asis"}
set.caption(paste0("Fisher's Exact Test for Count Data: ",
			paste(containedCount$hyper[c("background", "cis")], collapse=" and "), " out of ", 
			paste(totalCount[c("background", "cis")], collapse=" and "), " respectively."))
pander(fisherTest$hyper$cis, style="rmarkdown")
```
 
 The distribution of distances paint a similar picture. There is a pronunced
 shift in the location of eSNPs towards hypo-sensitive regions when compared
 to the distribution of all imputed SNPs. The difference observed in the distance
 from hyper-sensitive sites on the other hand is very small.
 
```{r methDistLeadPlot, echo=FALSE, warning=FALSE, fig.cap="Distance from lead SNP to nearest methylation island"}
ggplot(methDistDF, aes(x=distance, colour=eQTL)) + geom_density() + facet_grid( ~ feature) +
		theme_bw() + scale_x_log10()
```

# Histone modification data
## Data processing
The Blueprint consortium provides BED files with peak calls for a number of 
histone modifications obtained from neutrophils. As with the methylation data
the format of the BED files is non-standard and the first five columns have to be
extracted prior to further processing.

```{r reformatBED2, engine="bash", echo=FALSE, cache=TRUE}
for file in $(ls blueprint/ChIPSeq_Neut/*.bed.gz)
do
	file="blueprint/ChIPSeq_Neut/$(basename $file .gz)"
	zcat $file | cut -f1-5 | gzip -c > ${file}5.gz
done	
```

```{r loadChIP, echo=FALSE, cache=TRUE}
chip <- loadBlueprint(dir("blueprint/ChIPSeq_Neut", ".bed5.gz", full.names=TRUE))
```
There are `r length(levels(chip$meta$type))` different histone modifications
in the data set with varying numbers of samples (see `r tabRef("sampleOverview")`).

```{r sampleOverviewTable, echo=FALSE, results="asis"}
set.caption(tabRef("sampleOverview", "Summary of available ChIP-seq samples"))
tmp <- as.matrix(table(chip$meta$type))
colnames(tmp) <- "Samples"
pander(tmp, style="rmarkdown")
```

The single sample with H2A_Zac ChIP data is excluded from further analysis.

```{r excludeZac, echo=FALSE, cache=TRUE, dependson="loadChIP"}
chip$ranges <- chip$ranges[chip$meta$type != "H2A_Zac"]
chip$meta <- subset(chip$meta, type != "H2A_Zac")
chip$meta$type <- factor(as.character(chip$meta$type))
```

```{r peakSummary, echo=FALSE, cache=TRUE, dependson="excludeZac"}
chip$meta$`peak count` <- sapply(chip$ranges, length)
chip$meta$`median width` <- sapply(chip$ranges, function(x) median(width(x)))
```

Considering high level summaries of the data, the variation in peak calls between samples
appears to be largely as one might expect (see `r figRef("peakCount")` and 
`r figRef("peakWidth")`). The only potential issue highlighted by these summaries
is the consistently low number of peaks for sample *C001UYH1*. This could indicate
a problem with identifying peaks in this sample. Since we will be considering
consensus peak calls accross samples this may not be an issue. 

```{r peakCountPlot, echo=FALSE, fig.cap=figRef("peakCount", "Number of ChIP-seq peaks called for each histone modification per sample.")}
ggplot(chip$meta, aes(x=type, y=`peak count`, colour=sample)) + 
		geom_point(size=2.5) + geom_line(aes(group=sample), linetype="dotted") + 
		theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
		xlab("") + ylab("Nubmer of peaks")
```

```{r peakWidthPlot, echo=FALSE, fig.cap=figRef("peakWidth", "Median width of ChIP-seq peaks for each histone modification per sample.")}
ggplot(chip$meta, aes(x=type, y=`median width`, colour=sample)) + 
		geom_point(size=2.5) + geom_line(aes(group=sample), linetype="dotted") + 
		theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
		xlab("") + ylab("Median peak width")
```

## Define location of histone modifications
To obtain a set of peak calls for each histone modification that can be considered 
a consensus across all available samples we only consider peaks that are supported
by at least three samples.

```{r definePeaks, echo=FALSE, cache=TRUE, dependson="excludeZac"}
chipPeaks <- tapply(chip$ranges, chip$meta$type, 
		function(x) slice(coverage(GRangesList(x)), lower=min(length(x), 3), 
				rangesOnly=TRUE))
chipPeaks <- lapply(chipPeaks, as, "GRanges")
for(i in 1:length(chipPeaks)){
	chip$meta$`consolidated count`[chip$meta$type == names(chipPeaks)[i]] <- 
			length(chipPeaks[[i]])
	chip$meta$`consolidated peak width`[chip$meta$type == names(chipPeaks)[i]] <-
			median(width(chipPeaks[[i]]))
}
```

To assess the effect this has on the overall distribution of identified histone marks
we compare the number and length of peaks obtained before and after consolidating peak 
calls. As `r figRef("comparePeakCount")` shows, this generally results in peak counts
that appear to be a reasonable approximation of the average peak count for each
histone modification. Similarly, the length of the resulting regions appears to be largely 
consistent with the lengths observed in idividual samples. For some marks,
H3K27me3 and H3K36me3 in particular, peaks seem to be noticibly shortened. While some
shortening of peaks is expected, a less substantial change would be desireable.
As far as annotating eQTL is concerded the effect is likely to be minor, however.

```{r comparePeakCountPlot, echo=FALSE, fig.cap=figRef("comparePeakCount", "Difference in the number of peaks before and after consolidating samples")}
ggplot(chip$meta, aes(x=`peak count`, y=`consolidated count`, colour=sample, shape=type)) + 
		geom_point() + geom_abline(intercept=0, slope=1) + theme_bw()
```

```{r compareWidthPlot, echo=FALSE, fig.cap=figRef("compareWidth", "Difference in peak width before and after consolidating samples.")}
ggplot(chip$meta, aes(x=`median width`, y=`consolidated peak width`, colour=sample, shape=type)) + 
		geom_point() + geom_abline(intercept=0, slope=1) + theme_bw()
```

```{r groupedMarks, echo=FALSE, cache=TRUE}
activatingMarks <- c("H3K27ac", "H3K36me3", "H3K4me3")
repressiveMarks <- c("H3K27me3", "H3K9me3")
chipPeaks$activating <- Reduce(union, chipPeaks[activatingMarks])
chipPeaks$repressive <- Reduce(union, chipPeaks[repressiveMarks]) 
```

In addition to considering individual histone marks we are also considering groups 
broader groups with related effects. `r pander(activatingMarks)` are grouped together
as activating marks and `r pander(repressiveMarks)` are grouped together as repressive
marks. Furthermore, we define to types of enhancer marks by considering
*H3K4me1* and whether it occurs together or without *H3K27ac*. The former indicates 
an active and the latter a poised enhancer.

```{r enhancerMarks, echo=FALSE, cache=TRUE}
overlapCount <- countOverlaps(chipPeaks$H3K4me1, chipPeaks$H3K27ac)
chipPeaks$`active enhancer` <- chipPeaks$H3K4me1[overlapCount > 0]
chipPeaks$`poised enhancer` <- chipPeaks$H3K4me1[overlapCount == 0]
```

Based on these definitions there are `r length(chipPeaks$activating)` activating and
`r length(chipPeaks$repressive)` repressive marks as well as 
`r length(chipPeaks[["active enhancer"]])` active and 
`r length(chipPeaks[["poised enhancer"]])` poised enhancers.


# Appendix {-}
## Custom functions used
```{r, ref.label="functions", eval=FALSE, echo=TRUE}
```

## Session Info
```{r sessionInfo, echo=FALSE}
sessionInfo()
```
